/**
 * GitLyte v2 Site Generator
 *
 * Generates static HTML sites using:
 * - Tailwind CDN for styling (no build step required)
 * - AI-driven design decisions
 * - Repository-aware content generation
 */

import type { AIProviderInstance } from "../utils/ai-provider.js";
import {
  cleanHtmlResponse,
  cleanJsonResponse,
} from "../utils/ai-response-cleaner.js";
import type { ResolvedConfigV2 } from "../types/v2-config.js";
import {
  refinePage,
  shouldUseSelfRefine,
  type RefinementContext,
  type RefinementResult,
} from "./self-refine.js";

/**
 * Repository analysis result
 */
export interface RepositoryAnalysis {
  name: string;
  description: string;
  projectType: "library" | "tool" | "webapp" | "docs" | "other";
  primaryLanguage: string;
  audience: "developers" | "designers" | "general" | "enterprise";
  style: "minimal" | "professional" | "creative" | "technical";
  keyFeatures: string[];
  /** Indicates if fallback values were used due to AI parsing failure */
  usedFallback?: boolean;
}

/**
 * Design system generated by AI
 */
export interface DesignSystem {
  colors: {
    primary: string;
    secondary: string;
    accent: string;
    background: string;
    text: string;
  };
  typography: {
    headingFont: string;
    bodyFont: string;
  };
  layout: "hero-centered" | "hero-split" | "minimal" | "feature-grid";
  /** Indicates if fallback values were used due to AI parsing failure */
  usedFallback?: boolean;
}

/**
 * Generated page content
 */
export interface GeneratedPage {
  path: string;
  html: string;
}

/**
 * Generated site result
 */
export interface GeneratedSite {
  pages: GeneratedPage[];
  assets: Array<{
    path: string;
    content: string | Buffer;
  }>;
  /** Refinement result (only present when quality: "high") */
  refinement?: RefinementResult;
}

/**
 * Analyze a repository using AI
 */
export async function analyzeRepository(
  repoInfo: {
    name: string;
    description: string;
    readme?: string;
    language?: string;
    topics?: string[];
  },
  aiProvider: AIProviderInstance
): Promise<RepositoryAnalysis> {
  const prompt = `Analyze this GitHub repository and determine its characteristics.

Repository: ${repoInfo.name}
Description: ${repoInfo.description}
Primary Language: ${repoInfo.language || "Unknown"}
Topics: ${repoInfo.topics?.join(", ") || "None"}
${repoInfo.readme ? `\nREADME (first 2000 chars):\n${repoInfo.readme.slice(0, 2000)}` : ""}

Respond with JSON only (no markdown, no explanation):
{
  "name": "${repoInfo.name}",
  "description": "concise 1-sentence description",
  "projectType": "library|tool|webapp|docs|other",
  "primaryLanguage": "the main programming language",
  "audience": "developers|designers|general|enterprise",
  "style": "minimal|professional|creative|technical",
  "keyFeatures": ["feature1", "feature2", "feature3"]
}`;

  const result = await aiProvider.generateText({
    prompt,
    taskType: "analysis",
  });

  try {
    const parsed = JSON.parse(
      cleanJsonResponse(result.text)
    ) as RepositoryAnalysis;
    return { ...parsed, usedFallback: false };
  } catch (error) {
    // Log warning and return fallback with indicator
    const errorMessage = error instanceof Error ? error.message : String(error);
    console.warn(
      `[v2-site-generator] Failed to parse repository analysis for "${repoInfo.name}": ${errorMessage}`,
      `\n  Raw response (first 200 chars): ${result.text?.slice(0, 200)}`
    );
    return {
      name: repoInfo.name,
      description: repoInfo.description,
      projectType: "other",
      primaryLanguage: repoInfo.language || "Unknown",
      audience: "developers",
      style: "professional",
      keyFeatures: [],
      usedFallback: true,
    };
  }
}

/**
 * Generate a design system based on repository analysis
 */
export async function generateDesignSystem(
  analysis: RepositoryAnalysis,
  aiProvider: AIProviderInstance
): Promise<DesignSystem> {
  const prompt = `Create a design system for a ${analysis.projectType} project.

Project: ${analysis.name}
Description: ${analysis.description}
Audience: ${analysis.audience}
Style: ${analysis.style}
Language: ${analysis.primaryLanguage}

Generate a modern, visually appealing design system. Use Tailwind CSS color names (e.g., "blue-600", "gray-900").

Respond with JSON only (no markdown, no explanation):
{
  "colors": {
    "primary": "tailwind-color (e.g., blue-600)",
    "secondary": "tailwind-color",
    "accent": "tailwind-color",
    "background": "tailwind-color (e.g., white or gray-50)",
    "text": "tailwind-color (e.g., gray-900)"
  },
  "typography": {
    "headingFont": "font-family name (e.g., Inter, system-ui)",
    "bodyFont": "font-family name"
  },
  "layout": "hero-centered|hero-split|minimal|feature-grid"
}`;

  const result = await aiProvider.generateText({
    prompt,
    taskType: "design",
  });

  try {
    const parsed = JSON.parse(cleanJsonResponse(result.text)) as DesignSystem;
    return { ...parsed, usedFallback: false };
  } catch (error) {
    // Log warning and return fallback with indicator
    const errorMessage = error instanceof Error ? error.message : String(error);
    console.warn(
      `[v2-site-generator] Failed to parse design system for "${analysis.name}": ${errorMessage}`,
      `\n  Raw response (first 200 chars): ${result.text?.slice(0, 200)}`
    );
    return {
      colors: {
        primary: "blue-600",
        secondary: "indigo-600",
        accent: "purple-500",
        background: "white",
        text: "gray-900",
      },
      typography: {
        headingFont: "Inter, system-ui, sans-serif",
        bodyFont: "Inter, system-ui, sans-serif",
      },
      layout: "hero-centered",
      usedFallback: true,
    };
  }
}

/**
 * Generate the index page HTML
 */
export async function generateIndexPage(
  analysis: RepositoryAnalysis,
  design: DesignSystem,
  config: ResolvedConfigV2,
  aiProvider: AIProviderInstance
): Promise<string> {
  const prompt = `Generate a modern, beautiful landing page HTML for this project.

PROJECT INFO:
- Name: ${analysis.name}
- Description: ${analysis.description}
- Type: ${analysis.projectType}
- Key Features: ${analysis.keyFeatures.join(", ")}
- Audience: ${analysis.audience}

DESIGN SYSTEM:
- Primary color: ${design.colors.primary}
- Secondary color: ${design.colors.secondary}
- Accent color: ${design.colors.accent}
- Background: ${design.colors.background}
- Text: ${design.colors.text}
- Layout: ${design.layout}

REQUIREMENTS:
1. Use Tailwind CSS classes only (loaded via CDN)
2. Include: hero section, features section, footer
3. Make it responsive (mobile-first)
4. Use modern design patterns (gradients, shadows, rounded corners)
5. Include smooth hover effects
6. No external images - use gradients or emoji as placeholders
7. Include a GitHub link placeholder

OUTPUT: Return ONLY the complete HTML document, no explanation. Start with <!DOCTYPE html>.`;

  const result = await aiProvider.generateText({
    prompt,
    taskType: "content",
    maxOutputTokens: 4000,
  });

  let html = result.text;

  // Clean up the response
  html = cleanHtmlResponse(html);

  // Ensure Tailwind CDN is included
  if (!html.includes("tailwindcss")) {
    html = html.replace(
      "</head>",
      `  <script src="https://cdn.tailwindcss.com"></script>\n  </head>`
    );
  }

  // Add logo if configured
  if (config.logo?.path) {
    // Replace placeholder logo with actual logo path
    html = html.replace(
      /<!--\s*LOGO_PLACEHOLDER\s*-->/g,
      `<img src="${config.logo.path}" alt="${config.logo.alt || analysis.name}" class="h-8 w-auto" />`
    );
  }

  // Add favicon if configured
  if (config.favicon?.path) {
    if (!html.includes('rel="icon"')) {
      html = html.replace(
        "</head>",
        `  <link rel="icon" href="${config.favicon.path}" />\n  </head>`
      );
    }
  }

  return html;
}

/**
 * Generate a complete site
 */
export async function generateSite(
  repoInfo: {
    name: string;
    description: string;
    readme?: string;
    language?: string;
    topics?: string[];
    url: string;
  },
  config: ResolvedConfigV2,
  aiProvider: AIProviderInstance
): Promise<GeneratedSite> {
  // Step 1: Analyze repository
  const analysis = await analyzeRepository(repoInfo, aiProvider);

  // Step 2: Generate design system
  const design = await generateDesignSystem(analysis, aiProvider);

  // Step 3: Generate pages
  const pages: GeneratedPage[] = [];
  let refinementResult: RefinementResult | undefined;

  // Always generate index page
  let indexHtml = await generateIndexPage(analysis, design, config, aiProvider);

  // Step 4: Apply Self-Refine if quality mode is "high"
  if (shouldUseSelfRefine(config.ai.quality)) {
    console.log(
      "[v2-site-generator] Quality mode is 'high', applying Self-Refine..."
    );

    const refinementContext: RefinementContext = {
      analysis,
      design,
      repositoryInfo: {
        name: repoInfo.name,
        description: repoInfo.description,
        language: repoInfo.language || "Unknown",
        topics: repoInfo.topics || [],
      },
    };

    refinementResult = await refinePage(
      indexHtml,
      refinementContext,
      aiProvider
    );

    indexHtml = refinementResult.html;

    console.log(
      `[v2-site-generator] Self-Refine complete. Score: ${refinementResult.finalEvaluation.overallScore}/5, ` +
        `Iterations: ${refinementResult.iterations}, ` +
        `Improved: ${refinementResult.improved ? "Yes" : "No"}`
    );
  }

  pages.push({
    path: "index.html",
    html: indexHtml,
  });

  // Generate additional pages based on config
  for (const pageName of config.pages) {
    const pageHtml = await generateAdditionalPage(
      pageName,
      analysis,
      design,
      aiProvider
    );
    pages.push({
      path: `${pageName}.html`,
      html: pageHtml,
    });
  }

  return {
    pages,
    assets: [], // Assets would be handled separately (logo, favicon, etc.)
    refinement: refinementResult,
  };
}

/**
 * Generate additional pages (features, docs, etc.)
 */
async function generateAdditionalPage(
  pageName: string,
  analysis: RepositoryAnalysis,
  design: DesignSystem,
  aiProvider: AIProviderInstance
): Promise<string> {
  const pageDescriptions: Record<string, string> = {
    features: "a detailed features page with expandable sections",
    docs: "a documentation overview page with navigation",
    api: "an API reference page with code examples",
    examples: "an examples gallery page with code snippets",
    changelog: "a changelog page showing version history",
  };

  const prompt = `Generate ${pageDescriptions[pageName] || `a ${pageName} page`} HTML for this project.

PROJECT: ${analysis.name} - ${analysis.description}
DESIGN: Primary ${design.colors.primary}, Background ${design.colors.background}

REQUIREMENTS:
1. Use Tailwind CSS classes only
2. Include navigation back to home
3. Make it responsive
4. Match the main site design aesthetic

OUTPUT: Return ONLY the complete HTML document. Start with <!DOCTYPE html>.`;

  const result = await aiProvider.generateText({
    prompt,
    taskType: "content",
    maxOutputTokens: 3000,
  });

  return cleanHtmlResponse(result.text);
}
