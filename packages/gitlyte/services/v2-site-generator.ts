/**
 * GitLyte v2 Site Generator
 *
 * Generates static HTML sites using:
 * - Tailwind CDN for styling (no build step required)
 * - AI-driven design decisions
 * - Repository-aware content generation
 */

import type { AIProviderInstance } from "../utils/ai-provider.js";
import type { ResolvedConfigV2 } from "../types/v2-config.js";

/**
 * Repository analysis result
 */
export interface RepositoryAnalysis {
  name: string;
  description: string;
  projectType: "library" | "tool" | "webapp" | "docs" | "other";
  primaryLanguage: string;
  audience: "developers" | "designers" | "general" | "enterprise";
  style: "minimal" | "professional" | "creative" | "technical";
  keyFeatures: string[];
}

/**
 * Design system generated by AI
 */
export interface DesignSystem {
  colors: {
    primary: string;
    secondary: string;
    accent: string;
    background: string;
    text: string;
  };
  typography: {
    headingFont: string;
    bodyFont: string;
  };
  layout: "hero-centered" | "hero-split" | "minimal" | "feature-grid";
}

/**
 * Generated page content
 */
export interface GeneratedPage {
  path: string;
  html: string;
}

/**
 * Generated site result
 */
export interface GeneratedSite {
  pages: GeneratedPage[];
  assets: Array<{
    path: string;
    content: string | Buffer;
  }>;
}

/**
 * Analyze a repository using AI
 */
export async function analyzeRepository(
  repoInfo: {
    name: string;
    description: string;
    readme?: string;
    language?: string;
    topics?: string[];
  },
  aiProvider: AIProviderInstance
): Promise<RepositoryAnalysis> {
  const prompt = `Analyze this GitHub repository and determine its characteristics.

Repository: ${repoInfo.name}
Description: ${repoInfo.description}
Primary Language: ${repoInfo.language || "Unknown"}
Topics: ${repoInfo.topics?.join(", ") || "None"}
${repoInfo.readme ? `\nREADME (first 2000 chars):\n${repoInfo.readme.slice(0, 2000)}` : ""}

Respond with JSON only (no markdown, no explanation):
{
  "name": "${repoInfo.name}",
  "description": "concise 1-sentence description",
  "projectType": "library|tool|webapp|docs|other",
  "primaryLanguage": "the main programming language",
  "audience": "developers|designers|general|enterprise",
  "style": "minimal|professional|creative|technical",
  "keyFeatures": ["feature1", "feature2", "feature3"]
}`;

  const result = await aiProvider.generateText({
    prompt,
    taskType: "analysis",
  });

  try {
    return JSON.parse(cleanJsonResponse(result.text)) as RepositoryAnalysis;
  } catch {
    // Return fallback if parsing fails
    return {
      name: repoInfo.name,
      description: repoInfo.description,
      projectType: "other",
      primaryLanguage: repoInfo.language || "Unknown",
      audience: "developers",
      style: "professional",
      keyFeatures: [],
    };
  }
}

/**
 * Generate a design system based on repository analysis
 */
export async function generateDesignSystem(
  analysis: RepositoryAnalysis,
  aiProvider: AIProviderInstance
): Promise<DesignSystem> {
  const prompt = `Create a design system for a ${analysis.projectType} project.

Project: ${analysis.name}
Description: ${analysis.description}
Audience: ${analysis.audience}
Style: ${analysis.style}
Language: ${analysis.primaryLanguage}

Generate a modern, visually appealing design system. Use Tailwind CSS color names (e.g., "blue-600", "gray-900").

Respond with JSON only (no markdown, no explanation):
{
  "colors": {
    "primary": "tailwind-color (e.g., blue-600)",
    "secondary": "tailwind-color",
    "accent": "tailwind-color",
    "background": "tailwind-color (e.g., white or gray-50)",
    "text": "tailwind-color (e.g., gray-900)"
  },
  "typography": {
    "headingFont": "font-family name (e.g., Inter, system-ui)",
    "bodyFont": "font-family name"
  },
  "layout": "hero-centered|hero-split|minimal|feature-grid"
}`;

  const result = await aiProvider.generateText({
    prompt,
    taskType: "design",
  });

  try {
    return JSON.parse(cleanJsonResponse(result.text)) as DesignSystem;
  } catch {
    // Return fallback design system
    return {
      colors: {
        primary: "blue-600",
        secondary: "indigo-600",
        accent: "purple-500",
        background: "white",
        text: "gray-900",
      },
      typography: {
        headingFont: "Inter, system-ui, sans-serif",
        bodyFont: "Inter, system-ui, sans-serif",
      },
      layout: "hero-centered",
    };
  }
}

/**
 * Generate the index page HTML
 */
export async function generateIndexPage(
  analysis: RepositoryAnalysis,
  design: DesignSystem,
  config: ResolvedConfigV2,
  aiProvider: AIProviderInstance
): Promise<string> {
  const prompt = `Generate a modern, beautiful landing page HTML for this project.

PROJECT INFO:
- Name: ${analysis.name}
- Description: ${analysis.description}
- Type: ${analysis.projectType}
- Key Features: ${analysis.keyFeatures.join(", ")}
- Audience: ${analysis.audience}

DESIGN SYSTEM:
- Primary color: ${design.colors.primary}
- Secondary color: ${design.colors.secondary}
- Accent color: ${design.colors.accent}
- Background: ${design.colors.background}
- Text: ${design.colors.text}
- Layout: ${design.layout}

REQUIREMENTS:
1. Use Tailwind CSS classes only (loaded via CDN)
2. Include: hero section, features section, footer
3. Make it responsive (mobile-first)
4. Use modern design patterns (gradients, shadows, rounded corners)
5. Include smooth hover effects
6. No external images - use gradients or emoji as placeholders
7. Include a GitHub link placeholder

OUTPUT: Return ONLY the complete HTML document, no explanation. Start with <!DOCTYPE html>.`;

  const result = await aiProvider.generateText({
    prompt,
    taskType: "content",
    maxOutputTokens: 4000,
  });

  let html = result.text;

  // Clean up the response
  html = cleanHtmlResponse(html);

  // Ensure Tailwind CDN is included
  if (!html.includes("tailwindcss")) {
    html = html.replace(
      "</head>",
      `  <script src="https://cdn.tailwindcss.com"></script>\n  </head>`
    );
  }

  // Add logo if configured
  if (config.logo?.path) {
    // Replace placeholder logo with actual logo path
    html = html.replace(
      /<!--\s*LOGO_PLACEHOLDER\s*-->/g,
      `<img src="${config.logo.path}" alt="${config.logo.alt || analysis.name}" class="h-8 w-auto" />`
    );
  }

  // Add favicon if configured
  if (config.favicon?.path) {
    if (!html.includes('rel="icon"')) {
      html = html.replace(
        "</head>",
        `  <link rel="icon" href="${config.favicon.path}" />\n  </head>`
      );
    }
  }

  return html;
}

/**
 * Generate a complete site
 */
export async function generateSite(
  repoInfo: {
    name: string;
    description: string;
    readme?: string;
    language?: string;
    topics?: string[];
    url: string;
  },
  config: ResolvedConfigV2,
  aiProvider: AIProviderInstance
): Promise<GeneratedSite> {
  // Step 1: Analyze repository
  const analysis = await analyzeRepository(repoInfo, aiProvider);

  // Step 2: Generate design system
  const design = await generateDesignSystem(analysis, aiProvider);

  // Step 3: Generate pages
  const pages: GeneratedPage[] = [];

  // Always generate index page
  const indexHtml = await generateIndexPage(
    analysis,
    design,
    config,
    aiProvider
  );
  pages.push({
    path: "index.html",
    html: indexHtml,
  });

  // Generate additional pages based on config
  for (const pageName of config.pages) {
    const pageHtml = await generateAdditionalPage(
      pageName,
      analysis,
      design,
      aiProvider
    );
    pages.push({
      path: `${pageName}.html`,
      html: pageHtml,
    });
  }

  return {
    pages,
    assets: [], // Assets would be handled separately (logo, favicon, etc.)
  };
}

/**
 * Generate additional pages (features, docs, etc.)
 */
async function generateAdditionalPage(
  pageName: string,
  analysis: RepositoryAnalysis,
  design: DesignSystem,
  aiProvider: AIProviderInstance
): Promise<string> {
  const pageDescriptions: Record<string, string> = {
    features: "a detailed features page with expandable sections",
    docs: "a documentation overview page with navigation",
    api: "an API reference page with code examples",
    examples: "an examples gallery page with code snippets",
    changelog: "a changelog page showing version history",
  };

  const prompt = `Generate ${pageDescriptions[pageName] || `a ${pageName} page`} HTML for this project.

PROJECT: ${analysis.name} - ${analysis.description}
DESIGN: Primary ${design.colors.primary}, Background ${design.colors.background}

REQUIREMENTS:
1. Use Tailwind CSS classes only
2. Include navigation back to home
3. Make it responsive
4. Match the main site design aesthetic

OUTPUT: Return ONLY the complete HTML document. Start with <!DOCTYPE html>.`;

  const result = await aiProvider.generateText({
    prompt,
    taskType: "content",
    maxOutputTokens: 3000,
  });

  return cleanHtmlResponse(result.text);
}

/**
 * Clean JSON response from AI
 */
function cleanJsonResponse(text: string): string {
  let cleaned = text.trim();

  // Remove markdown code blocks
  if (cleaned.startsWith("```json")) {
    cleaned = cleaned.slice(7);
  }
  if (cleaned.startsWith("```")) {
    cleaned = cleaned.slice(3);
  }
  if (cleaned.endsWith("```")) {
    cleaned = cleaned.slice(0, -3);
  }

  return cleaned.trim();
}

/**
 * Clean HTML response from AI
 */
function cleanHtmlResponse(text: string): string {
  let cleaned = text.trim();

  // Remove markdown code blocks
  if (cleaned.startsWith("```html")) {
    cleaned = cleaned.slice(7);
  }
  if (cleaned.startsWith("```")) {
    cleaned = cleaned.slice(3);
  }
  if (cleaned.endsWith("```")) {
    cleaned = cleaned.slice(0, -3);
  }

  // Ensure it starts with doctype
  if (!cleaned.toLowerCase().startsWith("<!doctype")) {
    const doctypeIndex = cleaned.toLowerCase().indexOf("<!doctype");
    if (doctypeIndex > -1) {
      cleaned = cleaned.slice(doctypeIndex);
    }
  }

  return cleaned.trim();
}
