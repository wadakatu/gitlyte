/**
 * GitLyte v2 Site Generator
 *
 * Generates static HTML sites using:
 * - Tailwind CDN for styling (no build step required)
 * - AI-driven design decisions
 * - Repository-aware content generation
 */

import type { AIProviderInstance } from "../utils/ai-provider.js";
import {
  cleanHtmlResponse,
  cleanJsonResponse,
} from "../utils/ai-response-cleaner.js";
import type { ResolvedConfigV2 } from "../types/v2-config.js";
import {
  refinePage,
  shouldUseSelfRefine,
  type RefinementContext,
  type RefinementResult,
} from "./self-refine.js";
import {
  analyzeSections,
  generateSectionsParallel,
  assembleHtml,
  type SectionContext,
} from "./section-generator.js";

/**
 * Repository analysis result
 */
export interface RepositoryAnalysis {
  name: string;
  description: string;
  projectType: "library" | "tool" | "webapp" | "docs" | "other";
  primaryLanguage: string;
  audience: "developers" | "designers" | "general" | "enterprise";
  style: "minimal" | "professional" | "creative" | "technical";
  keyFeatures: string[];
  /** Indicates if fallback values were used due to AI parsing failure */
  usedFallback?: boolean;
}

/**
 * Color palette for a single theme mode
 */
export interface ColorPalette {
  primary: string;
  secondary: string;
  accent: string;
  background: string;
  text: string;
}

/**
 * Design system generated by AI
 */
export interface DesignSystem {
  colors: {
    light: ColorPalette;
    dark: ColorPalette;
  };
  typography: {
    headingFont: string;
    bodyFont: string;
  };
  layout: "hero-centered" | "hero-split" | "minimal" | "feature-grid";
  /** Indicates if fallback values were used due to AI parsing failure */
  usedFallback?: boolean;
}

/**
 * Generated page content
 */
export interface GeneratedPage {
  path: string;
  html: string;
}

/**
 * Generated site result
 */
export interface GeneratedSite {
  pages: GeneratedPage[];
  assets: Array<{
    path: string;
    content: string | Buffer;
  }>;
  /** Refinement result (only present when quality: "high") */
  refinement?: RefinementResult;
}

/**
 * Analyze a repository using AI
 */
export async function analyzeRepository(
  repoInfo: {
    name: string;
    description: string;
    readme?: string;
    language?: string;
    topics?: string[];
  },
  aiProvider: AIProviderInstance
): Promise<RepositoryAnalysis> {
  const prompt = `Analyze this GitHub repository and determine its characteristics.

Repository: ${repoInfo.name}
Description: ${repoInfo.description}
Primary Language: ${repoInfo.language || "Unknown"}
Topics: ${repoInfo.topics?.join(", ") || "None"}
${repoInfo.readme ? `\nREADME (first 2000 chars):\n${repoInfo.readme.slice(0, 2000)}` : ""}

Respond with JSON only (no markdown, no explanation):
{
  "name": "${repoInfo.name}",
  "description": "concise 1-sentence description",
  "projectType": "library|tool|webapp|docs|other",
  "primaryLanguage": "the main programming language",
  "audience": "developers|designers|general|enterprise",
  "style": "minimal|professional|creative|technical",
  "keyFeatures": ["feature1", "feature2", "feature3"]
}`;

  const result = await aiProvider.generateText({
    prompt,
    taskType: "analysis",
  });

  try {
    const parsed = JSON.parse(
      cleanJsonResponse(result.text)
    ) as RepositoryAnalysis;
    return { ...parsed, usedFallback: false };
  } catch (error) {
    // Log warning and return fallback with indicator
    const errorMessage = error instanceof Error ? error.message : String(error);
    console.warn(
      `[v2-site-generator] Failed to parse repository analysis for "${repoInfo.name}": ${errorMessage}`,
      `\n  Raw response (first 200 chars): ${result.text?.slice(0, 200)}`
    );
    return {
      name: repoInfo.name,
      description: repoInfo.description,
      projectType: "other",
      primaryLanguage: repoInfo.language || "Unknown",
      audience: "developers",
      style: "professional",
      keyFeatures: [],
      usedFallback: true,
    };
  }
}

/**
 * Generate a design system based on repository analysis
 */
export async function generateDesignSystem(
  analysis: RepositoryAnalysis,
  aiProvider: AIProviderInstance
): Promise<DesignSystem> {
  const prompt = `Create a design system for a ${analysis.projectType} project.

Project: ${analysis.name}
Description: ${analysis.description}
Audience: ${analysis.audience}
Style: ${analysis.style}
Language: ${analysis.primaryLanguage}

Generate a modern, visually appealing design system with BOTH light and dark mode color palettes.
Use Tailwind CSS color names (e.g., "blue-600", "gray-900").

For light mode: use lighter backgrounds (white, gray-50) with darker text (gray-900).
For dark mode: use darker backgrounds (gray-950, slate-900) with lighter text (gray-50, white).

Respond with JSON only (no markdown, no explanation):
{
  "colors": {
    "light": {
      "primary": "tailwind-color (e.g., blue-600)",
      "secondary": "tailwind-color",
      "accent": "tailwind-color",
      "background": "white or gray-50",
      "text": "gray-900"
    },
    "dark": {
      "primary": "tailwind-color (e.g., blue-400)",
      "secondary": "tailwind-color",
      "accent": "tailwind-color",
      "background": "gray-950 or slate-900",
      "text": "gray-50"
    }
  },
  "typography": {
    "headingFont": "font-family name (e.g., Inter, system-ui)",
    "bodyFont": "font-family name"
  },
  "layout": "hero-centered|hero-split|minimal|feature-grid"
}`;

  const result = await aiProvider.generateText({
    prompt,
    taskType: "design",
  });

  try {
    const parsed = JSON.parse(cleanJsonResponse(result.text)) as DesignSystem;
    return { ...parsed, usedFallback: false };
  } catch (error) {
    // Log warning and return fallback with indicator
    const errorMessage = error instanceof Error ? error.message : String(error);
    console.warn(
      `[v2-site-generator] Failed to parse design system for "${analysis.name}": ${errorMessage}`,
      `\n  Raw response (first 200 chars): ${result.text?.slice(0, 200)}`
    );
    return {
      colors: {
        light: {
          primary: "blue-600",
          secondary: "indigo-600",
          accent: "purple-500",
          background: "white",
          text: "gray-900",
        },
        dark: {
          primary: "blue-400",
          secondary: "indigo-400",
          accent: "purple-400",
          background: "gray-950",
          text: "gray-50",
        },
      },
      typography: {
        headingFont: "Inter, system-ui, sans-serif",
        bodyFont: "Inter, system-ui, sans-serif",
      },
      layout: "hero-centered",
      usedFallback: true,
    };
  }
}

/**
 * Generate the index page HTML
 */
export async function generateIndexPage(
  analysis: RepositoryAnalysis,
  design: DesignSystem,
  config: ResolvedConfigV2,
  aiProvider: AIProviderInstance
): Promise<string> {
  const palette = design.colors[config.theme.mode];
  const prompt = `Generate a modern, beautiful landing page HTML for this project.

PROJECT INFO:
- Name: ${analysis.name}
- Description: ${analysis.description}
- Type: ${analysis.projectType}
- Key Features: ${analysis.keyFeatures.join(", ")}
- Audience: ${analysis.audience}

DESIGN SYSTEM (${config.theme.mode} mode):
- Primary color: ${palette.primary}
- Secondary color: ${palette.secondary}
- Accent color: ${palette.accent}
- Background: ${palette.background}
- Text: ${palette.text}
- Layout: ${design.layout}

REQUIREMENTS:
1. Use Tailwind CSS classes only (loaded via CDN)
2. Include: hero section, features section, footer
3. Make it responsive (mobile-first)
4. Use modern design patterns (gradients, shadows, rounded corners)
5. Include smooth hover effects
6. No external images - use gradients or emoji as placeholders
7. Include a GitHub link placeholder

OUTPUT: Return ONLY the complete HTML document, no explanation. Start with <!DOCTYPE html>.`;

  const result = await aiProvider.generateText({
    prompt,
    taskType: "content",
    maxOutputTokens: 8000,
  });

  let html = result.text;

  // Clean up the response
  html = cleanHtmlResponse(html);

  // Validate HTML completeness
  if (!html.includes("</html>")) {
    console.warn(
      "[v2-site-generator] Generated HTML appears truncated (no </html> tag). " +
        `Output length: ${html.length} chars. This may indicate maxOutputTokens is too low.`
    );
    // Attempt to close the HTML properly
    html = `${html}\n</body>\n</html>`;
  }

  // Ensure Tailwind CDN is included
  if (!html.includes("tailwindcss")) {
    html = html.replace(
      "</head>",
      `  <script src="https://cdn.tailwindcss.com"></script>\n  </head>`
    );
  }

  // Add logo if configured
  if (config.logo?.path) {
    // Replace placeholder logo with actual logo path
    html = html.replace(
      /<!--\s*LOGO_PLACEHOLDER\s*-->/g,
      `<img src="${config.logo.path}" alt="${config.logo.alt || analysis.name}" class="h-8 w-auto" />`
    );
  }

  // Add favicon if configured
  if (config.favicon?.path) {
    if (!html.includes('rel="icon"')) {
      html = html.replace(
        "</head>",
        `  <link rel="icon" href="${config.favicon.path}" />\n  </head>`
      );
    }
  }

  return html;
}

/**
 * Generate a complete site using section-based parallel generation
 *
 * Architecture:
 * 1. Analyze repository to understand project context
 * 2. Generate design system (shared across all sections)
 * 3. Analyze which sections are needed based on project type
 * 4. Generate all sections in parallel (each section is small, no truncation)
 * 5. Assemble sections into final HTML
 * 6. Optionally apply Self-Refine for quality improvement
 */
export async function generateSite(
  repoInfo: {
    name: string;
    description: string;
    readme?: string;
    language?: string;
    topics?: string[];
    url: string;
  },
  config: ResolvedConfigV2,
  aiProvider: AIProviderInstance
): Promise<GeneratedSite> {
  console.log("[v2-site-generator] Starting section-based site generation...");

  // Step 1: Analyze repository
  console.log("[v2-site-generator] Step 1: Analyzing repository...");
  const analysis = await analyzeRepository(repoInfo, aiProvider);

  // Step 2: Generate design system
  console.log("[v2-site-generator] Step 2: Generating design system...");
  const design = await generateDesignSystem(analysis, aiProvider);

  // Step 3: Analyze which sections are needed
  console.log("[v2-site-generator] Step 3: Analyzing needed sections...");
  const sectionPlan = await analyzeSections(
    analysis,
    repoInfo.readme,
    aiProvider
  );
  console.log(
    `[v2-site-generator] Sections planned: ${sectionPlan.sections.join(", ")}`
  );
  console.log(`[v2-site-generator] Reasoning: ${sectionPlan.reasoning}`);

  // Step 4: Generate all sections in parallel
  console.log(
    `[v2-site-generator] Step 4: Generating ${sectionPlan.sections.length} sections in parallel...`
  );
  const sectionContext: SectionContext = {
    analysis,
    design,
    repoInfo: {
      name: repoInfo.name,
      description: repoInfo.description,
      readme: repoInfo.readme,
      url: repoInfo.url,
    },
    themeMode: config.theme.mode,
  };

  const sections = await generateSectionsParallel(
    sectionPlan,
    sectionContext,
    aiProvider
  );
  console.log(
    `[v2-site-generator] Generated ${sections.length} sections successfully`
  );

  // Step 5: Assemble final HTML
  console.log("[v2-site-generator] Step 5: Assembling final HTML...");
  let indexHtml = assembleHtml(sections, sectionContext, {
    favicon: config.favicon,
    logo: config.logo,
  });

  // Step 6: Apply Self-Refine if quality mode is "high"
  const pages: GeneratedPage[] = [];
  let refinementResult: RefinementResult | undefined;

  if (shouldUseSelfRefine(config.ai.quality)) {
    console.log(
      "[v2-site-generator] Step 6: Applying Self-Refine (quality: high)..."
    );

    const refinementContext: RefinementContext = {
      analysis,
      design,
      themeMode: config.theme.mode,
      repositoryInfo: {
        name: repoInfo.name,
        description: repoInfo.description,
        language: repoInfo.language || "Unknown",
        topics: repoInfo.topics || [],
      },
    };

    refinementResult = await refinePage(
      indexHtml,
      refinementContext,
      aiProvider
    );

    indexHtml = refinementResult.html;

    console.log(
      `[v2-site-generator] Self-Refine complete. Score: ${refinementResult.finalEvaluation.overallScore}/5, ` +
        `Iterations: ${refinementResult.iterations}, ` +
        `Improved: ${refinementResult.improved ? "Yes" : "No"}`
    );
  }

  pages.push({
    path: "index.html",
    html: indexHtml,
  });

  // Generate additional pages based on config (legacy support)
  for (const pageName of config.pages) {
    const pageHtml = await generateAdditionalPage(
      pageName,
      analysis,
      design,
      config,
      aiProvider
    );
    pages.push({
      path: `${pageName}.html`,
      html: pageHtml,
    });
  }

  console.log("[v2-site-generator] Site generation complete!");

  return {
    pages,
    assets: [],
    refinement: refinementResult,
  };
}

/**
 * Generate additional pages (features, docs, etc.)
 */
async function generateAdditionalPage(
  pageName: string,
  analysis: RepositoryAnalysis,
  design: DesignSystem,
  config: ResolvedConfigV2,
  aiProvider: AIProviderInstance
): Promise<string> {
  const palette = design.colors[config.theme.mode];
  const pageDescriptions: Record<string, string> = {
    features: "a detailed features page with expandable sections",
    docs: "a documentation overview page with navigation",
    api: "an API reference page with code examples",
    examples: "an examples gallery page with code snippets",
    changelog: "a changelog page showing version history",
  };

  const prompt = `Generate ${pageDescriptions[pageName] || `a ${pageName} page`} HTML for this project.

PROJECT: ${analysis.name} - ${analysis.description}
DESIGN (${config.theme.mode} mode): Primary ${palette.primary}, Background ${palette.background}

REQUIREMENTS:
1. Use Tailwind CSS classes only
2. Include navigation back to home
3. Make it responsive
4. Match the main site design aesthetic

OUTPUT: Return ONLY the complete HTML document. Start with <!DOCTYPE html>.`;

  const result = await aiProvider.generateText({
    prompt,
    taskType: "content",
    maxOutputTokens: 3000,
  });

  return cleanHtmlResponse(result.text);
}
