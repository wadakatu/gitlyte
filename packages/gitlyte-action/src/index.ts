import * as core from "@actions/core";
import * as github from "@actions/github";
import { generateSite } from "./site-generator.js";
import { createAIProvider, type AIProvider } from "./ai-provider.js";

async function run(): Promise<void> {
  try {
    // Get inputs
    const apiKey = core.getInput("api-key", { required: true });
    const provider = core.getInput("provider") as AIProvider;
    const quality = core.getInput("quality") as "standard" | "high";
    const outputDirectory = core.getInput("output-directory");
    const githubToken = core.getInput("github-token", { required: true });

    // Validate provider
    if (!["anthropic", "openai", "google"].includes(provider)) {
      throw new Error(
        `Invalid provider: ${provider}. Must be one of: anthropic, openai, google`
      );
    }

    // Get context
    const { context } = github;
    const octokit = github.getOctokit(githubToken);

    const owner = context.repo.owner;
    const repo = context.repo.repo;

    core.info(`üöÄ Starting GitLyte site generation for ${owner}/${repo}`);
    core.info(`üì¶ Provider: ${provider}, Quality: ${quality}`);

    // Get repository info
    const { data: repoData } = await octokit.rest.repos.get({ owner, repo });

    // Get README
    let readme: string | undefined;
    try {
      const { data: readmeData } = await octokit.rest.repos.getReadme({
        owner,
        repo,
      });
      if ("content" in readmeData) {
        readme = Buffer.from(readmeData.content, "base64").toString("utf-8");
      }
    } catch {
      core.info("üìÑ No README found, proceeding without it");
    }

    // Load config from .gitlyte.json if exists
    let config = {
      outputDirectory,
      theme: { mode: "dark" as const },
      prompts: {} as { siteInstructions?: string },
    };
    try {
      const { data: configFile } = await octokit.rest.repos.getContent({
        owner,
        repo,
        path: ".gitlyte.json",
      });
      if ("content" in configFile) {
        const configContent = Buffer.from(
          configFile.content,
          "base64"
        ).toString("utf-8");
        const parsedConfig = JSON.parse(configContent);
        config = {
          outputDirectory: parsedConfig.outputDirectory || outputDirectory,
          theme: { mode: parsedConfig.theme?.mode || "dark" },
          prompts: { siteInstructions: parsedConfig.prompts?.siteInstructions },
        };
      }
    } catch {
      core.info("üìÑ No .gitlyte.json found, using defaults");
    }

    // Create AI provider
    const aiProvider = createAIProvider(provider, quality, apiKey);

    // Generate site
    const repoInfo = {
      name: repoData.name,
      fullName: repoData.full_name,
      description: repoData.description || undefined,
      htmlUrl: repoData.html_url,
      language: repoData.language || undefined,
      topics: repoData.topics || [],
      readme,
    };

    core.info("üé® Generating site...");
    const result = await generateSite(repoInfo, aiProvider, config);

    // Get default branch ref
    const { data: refData } = await octokit.rest.git.getRef({
      owner,
      repo,
      ref: `heads/${repoData.default_branch}`,
    });
    const parentSha = refData.object.sha;

    // Create tree with generated files
    const treeItems = result.pages.map((page) => ({
      path: `${config.outputDirectory}/${page.path}`,
      mode: "100644" as const,
      type: "blob" as const,
      content: page.html,
    }));

    // Add assets
    for (const asset of result.assets) {
      treeItems.push({
        path: `${config.outputDirectory}/${asset.path}`,
        mode: "100644" as const,
        type: "blob" as const,
        content: asset.content,
      });
    }

    const { data: treeData } = await octokit.rest.git.createTree({
      owner,
      repo,
      base_tree: parentSha,
      tree: treeItems,
    });

    // Create commit
    const commitMessage =
      "chore: update GitLyte generated site [skip gitlyte]\n\n" +
      "Generated by GitLyte v2 (GitHub Action)\n" +
      `Provider: ${provider}, Quality: ${quality}`;

    const { data: commitData } = await octokit.rest.git.createCommit({
      owner,
      repo,
      message: commitMessage,
      tree: treeData.sha,
      parents: [parentSha],
    });

    // Create branch
    const timestamp = Date.now();
    const branchName = `gitlyte/update-site-${timestamp}`;

    await octokit.rest.git.createRef({
      owner,
      repo,
      ref: `refs/heads/${branchName}`,
      sha: commitData.sha,
    });

    // Create PR
    const { data: prData } = await octokit.rest.pulls.create({
      owner,
      repo,
      title: "chore: update GitLyte generated site",
      head: branchName,
      base: repoData.default_branch,
      body:
        "## üöÄ GitLyte Site Update\n\n" +
        "This PR was automatically generated by GitLyte GitHub Action.\n\n" +
        `- **Provider**: ${provider}\n` +
        `- **Quality**: ${quality}\n` +
        `- **Output**: \`${config.outputDirectory}/\`\n\n` +
        "---\n" +
        "*Generated with [GitLyte](https://github.com/wadakatu/gitlyte)*",
    });

    core.info(`‚úÖ Site generated successfully!`);
    core.info(`üìù Pull Request: ${prData.html_url}`);

    // Set outputs
    core.setOutput("pr-url", prData.html_url);
    core.setOutput("pr-number", prData.number);
  } catch (error) {
    if (error instanceof Error) {
      core.setFailed(error.message);
    } else {
      core.setFailed("An unknown error occurred");
    }
  }
}

run();
